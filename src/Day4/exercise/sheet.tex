\documentclass{../../sheet}
\renewcommand{\logopath}{../../logos/}

\title{PSE Vorkurs Tag 4}

\begin{document}
\maketitle

\aufgabe{Präsentations-Cheatsheet}
\textbf{Klassensyntax:}
	\begin{minted}[linenos=false]{java}
public class Student {
    String name;
    int matrikelnummer;

    void lernen() {
	System.out.println(name + " lernt fleißig!");
    }
}
\end{minted}

\textbf{Konstruktorsyntax:}\\
Konstruktoren werden immer bei der Erstellung eines Objekts (also bei der Instanziierung) ausgeführt
	\begin{minted}[linenos=false]{java}
public class Student {
    private final String name;
    public int matrikelnummer;

    public Student(String name, int matrikelnummer) {
	this.name = name;
	this.matrikelnummer = matrikelnummer;
    }
}
	\end{minted}

\textbf{Instanzen von Klassen:}
	
	\begin{minted}[linenos=false]{java}
public Student(String name, int matrikelnummer) {
    this.name = name;
    this.matrikelnummer = matrikelnummer;
}

Student paul = new Student("Paul", 12345);
paul.lernen(); // → Paul lernt fleißig!

Student anna = new Student("Anna", 67890);

System.out.println(anna.matrikelnummer); // → 67890
anna.lernen(); // → Anna lernt fleißig!

	\end{minted}
	


\newpage

\aufgabe{Aufgabe 1: Klassen}
Heute werden wir eine Klassenstruktur umsetzen, die ein Modell für eine Grillung sein soll.

\begin{enumerate}
    \item In Java haben Klassen im Allgemeinen jeweils eine eigene Datei. Erstelle eine \texttt{Main}-Klassen-Datei, sowie eine \texttt{Grill}-Klassen-Datei. Man kann jetzt in der Main in einer Funktion auf die Grillklasse zugreifen, also diese zum Beispiel Instanziieren.
    \item Gib deiner Grillklasse einen Konstruktor, der ausgibt, dass ein neuer Grill erstellt wird. Teste den Konstruktor der Grillklasse in dem du ein Grillobjekt in der Main-\textit{Funktion} der Main-\textit{Klasse} erstellst und in einer Variable mit dem Typ \texttt{Grill} speicherst.
    \item Füge dem Grill Attribute hinzu. Jeder Grill sollte einen Grillmeister (Name als \texttt{String}), eine maximale Würstchenanzahl (\texttt{int}), eine maximale Hitze (\texttt{int}), sowie eine momentane Hitze (\texttt{int}) haben. Erweitere deinen Konstruktor so, dass auch die Attribute des Grills initialisiert werden, wenn ein neues Grillobjekt erstellt wird. Der Konstruktor soll nun den Namen des Grillmeisters, die maximale Würstchenanzahl und die maximale Hitze als Parameter entgegennehmen und setzen.
    \item Gib dem Grill eine oder mehrere Funktionen zur Kontrolle der Hitze. Gestalte sie so wie du es für sinnvoll hältst.
    \item Füge dem Grill ein Array der Größe \texttt{maximaleWuerstchen} hinzu, dass die Würstchen symbolisieren soll. Erstelle eine Funktion, um Würstchen auf den Grill zu legen, sowie eine um sie wieder runterzunehmen. Wenn an einer Stelle kein Würstchen liegt soll -1 and der Stelle im Array stehen. Ein Würstchen wird mit dem Wert 0 auf den Grill gelegt. Ein Würstchen ist durch, wenn sein ''Durchheitswert'' zwischen 10 und 15 ist. Wenn es über 15 gegrillt wird, dann ist es verbrannt. Die \texttt{runternehmen}-Funktion sollte ausgeben, ob das Würstchen roh, durch oder verbrannt ist.\\
    Hinweis: Vergiss nicht das Array im Konstruktor zu initialisieren.
    \item Füge dem Grill eine \texttt{Grillen} Funktion hinzu, die die momentane Hitze auf den Durchheitswert jeder Würstchen addiert.
    \item Nutze die main um einen Beispielhaften Grillablauf einer mehr oder weniger erfolgreichen Grillerei darzustellen. 
\end{enumerate}

\newpage
\aufgabe{Aufgabe 2: Klassen in Klassen}
Eine Sache, die dir vielleicht schon aufgefallen ist, ist dass wir momentan leider nur Würstchen Grillen können und auch bei denen nur genau eine Sorte. Dafür wird jetzt eine neue Grillgut-Klasse erstellt, die viel flexibler sein soll und unserer (leider digitalen) Grillung viel mehr ermöglichen wird.
\begin{enumerate}
    \item Erstelle eine neue Klasse (wieder mit neuer Datei) namens \texttt{Grillgut}. Sie soll einen Grillguttyp (\texttt{String}, z.B. Currywurst), einen minimalen Durchheitswert (\texttt{int}), einen maximalen Durchheitswert (\texttt{int}), einen momentanen Durchheitswert (\texttt{int}), eine Hitzetoleranz (\texttt{int}) und einen verbrannt (\texttt{Boolean}) Status haben. Wenn das Grillgut einmal mit einer Hitze größer der Hitzetoleranz gegrillt wird, dann ist es sofort verbrannt.
    \item Implementiere einen Konstruktor, der manche der obigen Attribute als Parameter entgegennimmt (die bei denen es dir sinnvoll erscheint), aber alle Attribute initialisiert, d.h. nach der Ausführung des Konstruktors sollten alle Attribute einen Wert haben.
    \item Erstelle eine \texttt{grillen} Funktion, die eine Hitze als Parameter entgegennimmt und das Grillgut entsprechend grillt. 
    \item Erstelle zudem eine \texttt{vomGrillNehmen} Funktion, die ausgibt, was gerade vom Grill genommen wurde und zudem in 5 Stufen ausgibt wie durch es ist:
    \begin{ausgabe}
Currywurst ist fertig, es ist noch roh.\\
Steak ist fertig, es ist durch.\\
Würstchen ist fertig, es ist gut durch.\\
Spieß ist fertig, es ist leider verbrannt.\\
Grillkäse ist fertig, er ist komplett schwarz gebrannt.
    \end{ausgabe}
    \item Gehe zurück zu deiner Grillklasse und ersetze das \texttt{int[] aufDemGrill} Array mit einem \texttt{Grillgut[] aufDemGrill}. Mache als Folge dessen sinnvolle Anpassungen in der Grillklasse, die die Funktionen aus Grillgut verwenden.
    \item Nutze die main-Funktion um einen neuen Beispielhaften Grillablauf einer mehr oder weniger erfolgreichen
    Grillung darzustellen, aber jetzt mit vielen unterschiedlichen Grillgütern.
\end{enumerate}

\newpage
\aufgabe{HIGHPERFORMER: Optimale Grillerei}
Stellt euch vor, es war ein langer Tag im PSE-Vorkurs und ihr habt euch eine Grillung verdient, doch der Grill ist klein und es gibt viele unterschiedliche Grillgüter, sowie viele hungrige Studis. Jetzt muss eine Methode her um möglichst schnell alles gegrillt zu bekommen und das natürlich ohne, dass ein einziges Stück verbrennt oder roh bleiben muss.
\begin{enumerate}
    \item Füge dem Grill einen Zähler hinzu, der bei jedem Aufruf der \texttt{grillen}-Funktion hochgezählt wird und ausgegeben wird. So kann die Dauer einer Grillerei gemessen werden.
    \item Programmiere eine Funktion die eine zufällige Anzahl an Grillgütern (zwischen 50 und 500) mit zufälligen minimalen und maximalen Durchheitswerten (achte jedoch drauf, dass der minimale Durchheitswert nie größer ist als der maximale), sowie zufälliger Hitzetoleranz (mindestens 1) generiert und in einem Array sammelt.
    \item Erstelle eine Funktion, die eins von den in der Highperformer-Aufgabe 1. generierten Arrays von \texttt{Grillgut}-Objekten entgegennimmt und in möglichst wenigen aufrufen der \texttt{grillen}-Funktion alle grillt. Nutze aus, dass nur die \texttt{grillen}-Funktion in der Zeit gezählt wird und man "kostenlos" die Hitze umstellen kann, sowie auf den Grill legen und wieder runternehmen kann. Es darf natürlich am Ende keine verbrannten oder rohen Würstchen geben. Wir haben einen beispielhaften (nicht-optimalen) Algorithmus \url{https://fius.de/index.php/pse-vk-folien/} gebastelt. Vielleicht kriegt ihr es hin, dass eurer im Durchschnitt schneller wird.
\end{enumerate}

\newpage
\aufgabe{Codeanhang}
Highperformer-Aufgabe:
\hypertarget{Highperformer}{}
\begin{minted}[linenos=false]{java}
public class Main{
    public static Grillgut[] optimaleGrillung(Grillgut[] eingabeGrillgut){
        //TODO hier wird gegrillt
    }
}
\end{minted}
\end{document}